// Generated by dts-bundle-generator v6.9.0

export declare enum PaymentFlow {
	DEFAULT = "DEFAULT",
	PREFER_VAULT = "PREFER_VAULT"
}
export declare enum ThreeDSecureStatus {
	SUCCESS = "AUTH_SUCCESS",
	FAILED = "AUTH_FAILED",
	SKIPPED = "SKIPPED",
	CHALLENGE = "CHALLENGE"
}
export interface PositionalConfig {
	container: string;
}
export interface PayPalOptions extends PositionalConfig {
	buttonColor?: "gold" | "blue" | "silver" | "white" | "black";
	buttonShape?: "pill" | "rect";
	buttonSize?: "small" | "medium" | "large" | "responsive";
	buttonHeight?: number;
	buttonLabel?: "checkout" | "credit" | "pay" | "buynow" | "paypal" | "installment";
	buttonTagline?: boolean;
	paymentFlow?: PaymentFlow;
}
export declare enum PaymentInstrumentType {
	ADYEN_PAYSHOP = "ADYEN_PAYSHOP",
	ADYEN_PAYTRAIL = "ADYEN_PAYTRAIL",
	ADYEN_MBWAY = "ADYEN_MBWAY",
	RAPYD_FAST = "RAPYD_FAST",
	RAPYD_PROMPTPAY = "RAPYD_PROMPTPAY",
	RAPYD_GCASH = "RAPYD_GCASH",
	RAPYD_POLI = "RAPYD_POLI",
	RAPYD_GRABPAY = "RAPYD_GRABPAY",
	TWOC2P = "TWOC2P",
	NETS = "NETS",
	STRIPE_GIROPAY = "STRIPE_GIROPAY",
	MOLLIE_GIROPAY = "MOLLIE_GIROPAY",
	MOLLIE_EPS = "MOLLIE_EPS",
	PAY_NL_EPS = "PAY_NL_EPS",
	PAY_NL_P24 = "PAY_NL_P24",
	MOLLIE_P24 = "MOLLIE_P24",
	MOLLIE_SOFORT = "MOLLIE_SOFORT",
	COINBASE = "COINBASE",
	OPENNODE = "OPENNODE",
	MOLLIE_GIFT_CARD = "MOLLIE_GIFTCARD",
	XFERS_PAYNOW = "XFERS_PAYNOW",
	CARD = "PAYMENT_CARD",
	APPLE_PAY = "APPLE_PAY",
	GOOGLE_PAY = "GOOGLE_PAY",
	PAYPAL = "PAYPAL_ORDER",
	PAYPAL_VAULTED = "PAYPAL_BILLING_AGREEMENT",
	GO_CARDLESS = "GOCARDLESS",
	PAY_NL_IDEAL = "PAY_NL_IDEAL",
	PAY_NL_SOFORT_BANKING = "PAY_NL_SOFORT_BANKING",
	PAY_NL_BANCONTACT = "PAY_NL_BANCONTACT",
	PAY_NL_PAYPAL = "PAY_NL_PAYPAL",
	PAY_NL_CREDIT_TRANSFER = "PAY_NL_CREDIT_TRANSFER",
	PAY_NL_DIRECT_DEBIT = "PAY_NL_DIRECT_DEBIT",
	PAY_NL_GIROPAY = "PAY_NL_GIROPAY",
	PAY_NL_PAYCONIQ = "PAY_NL_PAYCONIQ",
	HOOLAH = "HOOLAH",
	ADYEN_BLIK = "ADYEN_BLIK",
	ADYEN_VIPPS = "ADYEN_VIPPS",
	ADYEN_GIROPAY = "ADYEN_GIROPAY",
	ADYEN_SOFORT = "ADYEN_SOFORT",
	ADYEN_TRUSTLY = "ADYEN_TRUSTLY",
	ADYEN_ALIPAY = "ADYEN_ALIPAY",
	ADYEN_TWINT = "ADYEN_TWINT",
	ADYEN_MOBILEPAY = "ADYEN_MOBILEPAY",
	MOLLIE_BANCONTACT = "MOLLIE_BANCONTACT",
	MOLLIE_IDEAL = "MOLLIE_IDEAL",
	BUCKAROO_GIROPAY = "BUCKAROO_GIROPAY",
	BUCKAROO_EPS = "BUCKAROO_EPS",
	BUCKAROO_SOFORT = "BUCKAROO_SOFORT",
	BUCKAROO_BANCONTACT = "BUCKAROO_BANCONTACT",
	BUCKAROO_IDEAL = "BUCKAROO_IDEAL",
	ATOME = "ATOME"
}
export declare enum PaymentMethodType {
	ADYEN_PAYSHOP = "ADYEN_PAYSHOP",
	ADYEN_PAYTRAIL = "ADYEN_PAYTRAIL",
	ADYEN_MBWAY = "ADYEN_MBWAY",
	RAPYD_FAST = "RAPYD_FAST",
	RAPYD_PROMPTPAY = "RAPYD_PROMPTPAY",
	RAPYD_GCASH = "RAPYD_GCASH",
	RAPYD_POLI = "RAPYD_POLI",
	RAPYD_GRABPAY = "RAPYD_GRABPAY",
	TWOC2P = "TWOC2P",
	NETS = "NETS",
	STRIPE_GIROPAY = "STRIPE_GIROPAY",
	MOLLIE_GIROPAY = "MOLLIE_GIROPAY",
	MOLLIE_EPS = "MOLLIE_EPS",
	PAY_NL_EPS = "PAY_NL_EPS",
	PAY_NL_P24 = "PAY_NL_P24",
	MOLLIE_P24 = "MOLLIE_P24",
	MOLLIE_SOFORT = "MOLLIE_SOFORT",
	COINBASE = "COINBASE",
	OPENNODE = "OPENNODE",
	MOLLIE_GIFT_CARD = "MOLLIE_GIFTCARD",
	XFERS_PAYNOW = "XFERS_PAYNOW",
	PAYMENT_CARD = "PAYMENT_CARD",
	APPLE_PAY = "APPLE_PAY",
	GOOGLE_PAY = "GOOGLE_PAY",
	PAYPAL = "PAYPAL",
	GO_CARDLESS = "GOCARDLESS",
	KLARNA = "KLARNA",
	PAY_NL_IDEAL = "PAY_NL_IDEAL",
	PAY_NL_SOFORT_BANKING = "PAY_NL_SOFORT_BANKING",
	PAY_NL_BANCONTACT = "PAY_NL_BANCONTACT",
	PAY_NL_PAYPAL = "PAY_NL_PAYPAL",
	PAY_NL_CREDIT_TRANSFER = "PAY_NL_CREDIT_TRANSFER",
	PAY_NL_DIRECT_DEBIT = "PAY_NL_DIRECT_DEBIT",
	PAY_NL_GIROPAY = "PAY_NL_GIROPAY",
	PAY_NL_PAYCONIQ = "PAY_NL_PAYCONIQ",
	HOOLAH = "HOOLAH",
	ADYEN_BLIK = "ADYEN_BLIK",
	ADYEN_MOBILEPAY = "ADYEN_MOBILEPAY",
	ADYEN_VIPPS = "ADYEN_VIPPS",
	ADYEN_GIROPAY = "ADYEN_GIROPAY",
	ADYEN_SOFORT = "ADYEN_SOFORT",
	ADYEN_TRUSTLY = "ADYEN_TRUSTLY",
	ADYEN_ALIPAY = "ADYEN_ALIPAY",
	ADYEN_TWINT = "ADYEN_TWINT",
	ADYEN_BANK_TRANSFER = "ADYEN_BANK_TRANSFER",
	MOLLIE_BANCONTACT = "MOLLIE_BANCONTACT",
	MOLLIE_IDEAL = "MOLLIE_IDEAL",
	BUCKAROO_GIROPAY = "BUCKAROO_GIROPAY",
	BUCKAROO_EPS = "BUCKAROO_EPS",
	BUCKAROO_SOFORT = "BUCKAROO_SOFORT",
	BUCKAROO_BANCONTACT = "BUCKAROO_BANCONTACT",
	BUCKAROO_IDEAL = "BUCKAROO_IDEAL",
	ATOME = "ATOME"
}
export declare enum TokenType {
	SINGLE_USE = "SINGLE_USE",
	MULTI_USE = "MULTI_USE"
}
export declare type Callable<T extends unknown[] = [
], U = void> = (...args: T) => U;
export declare type Nullable<T> = T | null;
export declare type MaybeThunk<T> = T | Callable<[
], T>;
export declare type GooglePayButtonType = "long" | "short";
export declare type GooglePayButtonColor = "default" | "black" | "white";
export interface GooglePayOptions extends PositionalConfig {
	buttonType?: GooglePayButtonType;
	buttonColor?: GooglePayButtonColor;
}
export interface ApplePayOptions extends PositionalConfig {
	buttonType?: "plain" | "buy" | "set-up" | "donate" | "check-out" | "book" | "subscribe";
	buttonStyle?: "white" | "white-outline" | "black";
}
export interface DirectDebitOptions {
	customerCountryCode: Alpha2CountryCode;
	companyName: string;
	companyAddress: string;
	customerName?: string;
	customerEmail?: string;
	customerAddressLine1?: string;
	customerAddressLine2?: string;
	customerCity?: string;
	customerPostalCode?: string;
	iban?: string;
	submitButtonLabels?: {
		form?: Label;
		mandate: Label;
	};
}
export declare enum ErrorCode {
	INITIALIZATION_ERROR = "INITIALIZATION_ERROR",
	NO_PAYMENT_METHODS = "NO_PAYMENT_METHODS",
	PRIMER_TEARDOWN = "PRIMER_TEARDOWN",
	PRIMER_SERVER_ERROR = "PRIMER_SERVER_ERROR",
	THREE_DS_SETUP_ERROR = "THREE_DS_SETUP_ERROR",
	THREE_DS_AUTH_FAILED = "THREE_DS_AUTH_FAILED",
	THREE_DS_NEGOTIATION_ERROR = "THREE_DS_NEGOTIATION_ERROR",
	TOKENIZATION_ERROR = "TOKENIZATION_ERROR",
	DUPLICATE_PAYMENT_METHOD_ERROR = "DUPLICATE_PAYMENT_METHOD_ERROR",
	CARD_NUMBER_ERROR = "CARD_NUMBER_ERROR",
	PAYMENT_METHOD_NOT_SETUP = "PAYMENT_METHOD_NOT_SETUP",
	PAYMENT_METHOD_NOT_PROVIDED = "PAYMENT_METHOD_NOT_SETUP",
	PAYMENT_METHOD_NOT_COMPATIBLE = "PAYMENT_METHOD_NOT_COMPATIBLE",
	RESUME_ERROR = "RESUME_ERROR",
	TAX_ERROR = "TAX_ERROR",
	VALIDATION_ERROR = "VALIDATION_ERROR"
}
export interface ErrorOptions {
	message: string;
	diagnosticsId?: string;
	errorId?: string;
	data?: any;
}
declare class PrimerClientError extends Error {
	code: ErrorCode;
	message: string;
	diagnosticsId: Nullable<string>;
	data?: any;
	static fromErrorCode(code: ErrorCode, options: ErrorOptions): PrimerClientError;
	constructor(code: ErrorCode, options: ErrorOptions);
}
export interface BorderStyle {
	borderStyle?: string;
	borderColor?: number | string;
	borderWidth?: number | string;
}
export interface TextAlignmentStyle {
	textAlign?: string;
}
export interface TextStyle {
	color?: string;
	fontFamily?: string;
	fontWeight?: string;
	fontSize?: string;
	fontSmoothing?: string;
	lineHeight?: string;
	textTransform?: string;
	letterSpacing?: string;
}
export interface BlockStyle extends BorderStyle {
	background?: string;
	borderRadius?: number | string;
	boxShadow?: string;
}
export declare type LogoColor = "DARK" | "LIGHT" | "COLORED";
export interface LoadingScreenStyle {
	color?: string;
}
export interface BaseInputStyle extends TextStyle, BlockStyle {
	height?: number | string;
	paddingHorizontal?: number;
}
export interface InputStyle extends BaseInputStyle {
	hover?: BaseInputStyle;
	focus?: BaseInputStyle;
	placeholder?: BaseInputStyle;
	webkitAutofill?: BaseInputStyle;
	selection?: BaseInputStyle;
}
export interface BaseSubmitButtonStyle extends TextStyle, BlockStyle {
}
export interface SubmitButtonStyle extends BaseSubmitButtonStyle {
	hover?: BaseSubmitButtonStyle;
	focus?: BaseSubmitButtonStyle;
}
export interface SubmitButtonStyles {
	base?: SubmitButtonStyle;
	disabled?: SubmitButtonStyle;
	loading?: SubmitButtonStyle;
}
export interface InputStyles {
	base?: InputStyle;
	error?: InputStyle;
}
export interface BaseSavedPaymentMethodButtonStyle extends TextStyle, BlockStyle {
}
export interface SavedPaymentMethodButtonStyle extends BaseSavedPaymentMethodButtonStyle {
	hover?: BaseSavedPaymentMethodButtonStyle;
	focus?: BaseSavedPaymentMethodButtonStyle;
}
export interface SavedPaymentMethodButtonStyles {
	base?: SavedPaymentMethodButtonStyle;
	selected?: SavedPaymentMethodButtonStyle;
}
export interface ShowMorePaymentMethodsButtonStyles {
	base?: TextStyle;
	disabled?: TextStyle;
}
export interface DirectDebitMandateStyle {
	header?: TextStyle;
	label?: TextStyle;
	content?: TextStyle;
	creditorDetails?: TextStyle;
}
export interface DirectDebitSuccessStyle {
	icon?: {
		color?: string;
	};
}
export interface PaymentMethodButtonStyle extends BlockStyle {
	height?: number;
	primaryText?: TextStyle;
	logoColor?: LogoColor;
	marginTop?: string;
}
export interface BackButtonStyle {
	color?: string;
}
export interface EditButtonStyle {
	color?: string;
	background?: string;
}
export interface SeparatorStyle {
	color?: string;
}
export interface ErrorMessageStyle extends BlockStyle, TextStyle {
	color?: string;
}
export interface FormSpacings {
	betweenLabelAndInput?: string;
	betweenInputs?: string;
}
export interface FontFace {
	fontFamily?: string;
	src?: string;
	unicodeRange?: string;
	fontVariant?: string;
	fontFeatureSettings?: string;
	fontVariationSettings?: string;
	fontStretch?: string;
	fontWeight?: string;
	fontStyle?: string;
}
export interface Stylesheet {
	href: string;
}
export interface VaultMenuStyle {
	editButton?: EditButtonStyle & TextStyle;
	item?: {
		label?: TextStyle;
		actionButton?: TextStyle;
		confirmButton?: BlockStyle & TextStyle;
	};
}
export interface SceneTransition {
	opacity?: string | number;
	transform?: string;
	transition?: string;
}
export interface SceneTransitionEventStyle {
	enter?: SceneTransition;
	entering?: SceneTransition;
	exit?: SceneTransition;
	exiting?: SceneTransition;
}
export interface SceneTransitionStyle extends SceneTransitionEventStyle {
	content: {
		transition?: string;
	};
	push?: SceneTransitionEventStyle;
	pop?: SceneTransitionEventStyle;
}
export interface InternalStyle {
	scene?: SceneTransitionStyle;
}
export interface NetworkErrorStyles {
	button?: {
		base: BlockStyle & TextStyle;
	};
}
export interface ProcessingIndicatorStyle {
	color?: string;
}
export interface CheckoutStyle {
	fontFaces?: Array<FontFace>;
	stylesheets?: Array<Stylesheet>;
	loadingScreen?: LoadingScreenStyle;
	input?: InputStyles;
	inputLabel?: TextStyle;
	inputErrorText?: TextStyle & TextAlignmentStyle;
	formSpacings?: FormSpacings;
	showMorePaymentMethodsButton?: ShowMorePaymentMethodsButtonStyles;
	networkError?: NetworkErrorStyles;
	submitButton?: SubmitButtonStyles;
	vaultTitle?: TextStyle;
	savedPaymentMethodButton?: SavedPaymentMethodButtonStyles;
	paymentMethodButton?: PaymentMethodButtonStyle;
	errorMessage?: ErrorMessageStyle;
	smallPrint?: TextStyle;
	directDebit?: {
		mandate?: DirectDebitMandateStyle;
		success?: DirectDebitSuccessStyle;
	};
	vaultMenu?: VaultMenuStyle;
	backButton?: BackButtonStyle;
	separator?: SeparatorStyle;
	processingIndicator?: ProcessingIndicatorStyle;
}
export declare enum CheckoutUXFlow {
	CHECKOUT = "CHECKOUT",
	MANAGE_PAYMENT_METHODS = "MANAGE_PAYMENT_METHODS",
	SINGLE_PAYMENT_METHOD_CHECKOUT = "SINGLE_PAYMENT_METHOD_CHECKOUT"
}
export interface CardMetadata {
	type: CardNetwork | null;
	possibleTypes: string[];
	cvvLength: number;
	cardNumberLength: number;
}
declare enum ProductType {
	DIGITAL = "DIGITAL",
	PHYSICAL = "PHYSICAL"
}
export interface ClientSession {
	clientSessionId: string;
	order: ClientSessionOrder;
	customer: ClientSessionCustomer;
	paymentMethod: ClientSessionPaymentMethodOptions;
}
export interface ClientSessionLineItem {
	itemId: string;
	description: string;
	amount: number;
	quantity: number;
	discountAmount?: number;
	taxCode?: string;
	taxAmount?: number;
	productType?: ProductType;
}
export interface ClientSessionOrder {
	orderId?: string;
	currencyCode?: Alpha3CurrencyCode;
	countryCode?: Alpha2CountryCode;
	totalOrderAmount?: number;
	merchantAmount?: number;
	lineItems?: ClientSessionLineItem[];
	shipping?: ClientSessionShipping;
	fees?: ClientSessionFeeItem[];
}
export interface ClientSessionShipping {
	amount: number;
}
export interface ClientSessionFeeItem {
	type?: string;
	description?: string;
	amount: number;
}
export interface ClientSessionCustomer {
	customerId?: string;
	emailAddress?: string;
	mobileNumber?: string;
	firstName?: string;
	lastName?: string;
	billingAddress?: ClientSessionAddress;
	shippingAddress?: ClientSessionAddress;
	taxId?: string;
	nationalDocumentId?: string;
}
export interface ClientSessionAddress {
	firstName?: string;
	lastName?: string;
	addressLine1?: string;
	addressLine2?: string;
	city?: string;
	state?: string;
	countryCode?: Alpha2CountryCode;
	postalCode?: string;
}
export interface ClientSessionPaymentMethodOptions {
	vaultOnSuccess: boolean;
	options: PaymentMethodOption[];
}
export interface PaymentMethodOption {
	type: string;
	surcharge?: number;
	networks?: CardNetworkOption[];
}
export interface CardNetworkOption {
	type: string;
	surcharge?: number;
}
export declare type KlarnaPaymentCategoryType = "pay_now" | "pay_later" | "pay_over_time";
export declare type KlarnaSupportedLocale = "de-AT" | "en-AT" | "da-DK" | "en-DK" | "fi-FI" | "sv-FI" | "en-FI" | "de-DE" | "en-DE" | "nl-NL" | "en-NL" | "nb-NO" | "en-NO" | "sv-SE" | "en-SE" | "de-CH" | "fr-CH" | "it-CH" | "en-CH" | "en-GB" | "en-US" | "en-AU" | "nl-BE" | "fr-BE" | "es-ES" | "it-IT";
export interface KlarnaAddress {
	title?: string;
	firstName?: string;
	lastName?: string;
	phoneNumber?: string;
	postalCode?: string;
	addressLine1?: string;
	addressLine2?: string;
	countryCode?: Alpha2CountryCode;
	city?: string;
	email?: string;
}
export interface KlarnaCustomerDetails {
	dateOfBirth?: string;
	gender?: "MALE" | "FEMALE";
	nationalIdentificationNumber?: string;
	title?: string;
}
export interface KlarnaOptions {
	paymentFlow?: PaymentFlow;
	recurringPaymentDescription?: string;
	allowedPaymentCategories?: KlarnaPaymentCategoryType[];
	shippingAddress: KlarnaAddress;
	billingAddress: KlarnaAddress;
}
export declare type SupportedLocale = string;
export declare type Alpha2CountryCode = "ES" | "FR" | "GB" | "DE" | "PL" | "IT" | "US";
export declare type Alpha3CurrencyCode = "EUR" | "GBP" | "USD";
export declare type ElementOrID = Nullable<string | HTMLElement>;
export declare type ValidationErrorType = "required" | "invalid";
export declare type Label<T extends Record<string, unknown> = Record<string, unknown>> = string | ((options: {
	locale: SupportedLocale;
} | T) => string);
export interface ClientContextOptions {
	credentials: PrimerClientCredentials;
	thirdPartyScriptTimeout?: number;
}
export declare type ResumeToken = {
	resumeToken: string;
	paymentId?: string;
};
export interface InputValidationError {
	name: string;
	error: string;
	message: string;
}
export interface Validation {
	valid: boolean;
	validationErrors: InputValidationError[];
	error?: string;
}
export interface InputMetadata {
	errorCode: string | null;
	error: string | null;
	valid: boolean;
	active: boolean;
	dirty: boolean;
	touched: boolean;
	submitted: boolean;
}
export interface FormState {
	dirty: boolean;
	touched: boolean;
	active: boolean;
	valid: boolean;
	submitted: boolean;
}
export declare type InlineStyleMap = Partial<Record<keyof CSSStyleDeclaration, string>>;
export interface PrimerClientCredentials {
	clientToken: string;
}
export interface PrimerClientOptions {
	credentials: PrimerClientCredentials;
}
export interface ExternalPayerInfo {
	externalPayerId: string;
	firstName?: string;
	lastName?: string;
	email?: string;
}
export interface BillingAddress {
	firstName?: string;
	lastName?: string;
	addressLine1?: string;
	addressLine2?: string;
	addressLine3?: string;
	city?: string;
	state?: string;
	countryCode?: Alpha2CountryCode;
	postalCode?: string;
}
export interface CustomerDetails {
	customerTaxId?: string;
	shippingAddress?: BillingAddress;
	billingAddress?: BillingAddress;
}
export interface BusinessDetails {
	address?: BillingAddress;
	nexusAddresses?: [
		BillingAddress
	];
}
export interface MonetaryAmount {
	value: number | string;
	currency: Alpha3CurrencyCode;
}
export interface OrderItem {
	name: string;
	unitAmount: number | string;
	reference?: string;
	quantity?: number;
	discountAmount?: number | string;
	taxCode?: string;
	productType?: ProductType;
}
export interface OrderDetails {
	totalAmount?: number | string;
	totalTaxAmount?: number | string;
	currencyCode?: Alpha3CurrencyCode;
	items?: OrderItem[];
	shippingAmount?: number | string;
	taxExemptionType?: string;
}
export interface ThreeDSecureOrderDetails {
	amount: MonetaryAmount;
	email: string;
	billingAddress: BillingAddress;
	orderId: string;
}
export interface ThreeDSVerificationOptions {
	token: string;
	container: string;
	order: ThreeDSecureOrderDetails;
	testScenario?: string;
	onChallengeStart?: () => void;
	onChallengeEnd?: () => void;
}
export interface ThreeDSAuthenticationData {
	responseCode: ThreeDSecureStatus;
	reasonCode?: string;
	reasonText?: string;
	protocolVersion: string;
	challengeIssued: boolean;
}
export interface VaultData {
	customerId: string;
}
export interface PaymentCardDetails {
	last4Digits: string;
	cardholderName: string;
	network: string;
}
export interface PayPalBillingAgreementDetails {
	paypalBillingAgreementId: string;
	externalPayerInfo?: ExternalPayerInfo;
	shippingAddress?: BillingAddress;
}
export interface GoCardlessDetails {
	gocardlessMandateId: string;
}
export interface IPaymentMethodToken<T, U extends PaymentInstrumentType> {
	token: string;
	analyticsId: string;
	tokenType: TokenType;
	paymentInstrumentData: T;
	paymentInstrumentType: U;
	threeDSecureAuthentication: Nullable<ThreeDSAuthenticationData>;
	vaultData: Nullable<VaultData>;
}
export declare type BaseAmountChange = {
	totalAmount: number;
};
export declare type TaxAmountChange = {
	reason: "TAX";
	totalTaxAmount: number;
};
export declare type AmountChange = BaseAmountChange & TaxAmountChange;
export declare type PaymentCardToken = IPaymentMethodToken<PaymentCardDetails, PaymentInstrumentType.CARD>;
export declare type PayPalBillingAgreementToken = IPaymentMethodToken<PayPalBillingAgreementDetails, PaymentInstrumentType.PAYPAL_VAULTED>;
export declare type GoCardlessToken = IPaymentMethodToken<GoCardlessDetails, PaymentInstrumentType.GO_CARDLESS>;
export declare type IdealPayToken = IPaymentMethodToken<Record<string, never>, PaymentInstrumentType.PAY_NL_IDEAL>;
export declare type PaymentMethodToken = PaymentCardToken | PayPalBillingAgreementToken | GoCardlessToken | IdealPayToken | IPaymentMethodToken<any, any>;
export interface ThreeDSVerificationResult<T extends ThreeDSecureStatus> {
	status: T;
	error: Nullable<PrimerClientError>;
	data: PaymentMethodToken;
	resumeToken: string;
}
export declare type ThreeDSVerification = ThreeDSVerificationResult<ThreeDSecureStatus.SUCCESS> | ThreeDSVerificationResult<ThreeDSecureStatus.FAILED> | ThreeDSVerificationResult<ThreeDSecureStatus.SKIPPED>;
export interface PurchaseInformation {
	totalAmount: MonetaryAmount;
}
export interface VaultInformation {
	totalAmount: {
		currency: Alpha3CurrencyCode;
	};
}
export interface VaultDetails {
	currencyCode: Alpha3CurrencyCode;
}
export declare type CardPreferredFlow = "DEDICATED_SCENE" | "EMBEDDED_IN_HOME";
export interface CheckoutCardOptions {
	css?: string;
	/**
	 * @deprecated Use `cardholderName.required` instead
	 */
	vault?: MaybeThunk<boolean>;
	cardholderName?: {
		/**
		 * Only works if the cardholder name is visible
		 */
		required?: boolean;
		/**
		 * @deprecated Set it on your Dashboard
		 */
		visible?: boolean;
		placeholder?: Label;
	};
	cardNumber?: {
		placeholder?: Label;
	};
	expiryDate?: {
		placeholder?: Label;
	};
	cvv?: {
		placeholder?: Label;
	};
	preferredFlow?: CardPreferredFlow;
}
export interface TransitionDurationOptions {
	enter?: number;
	exit?: number;
}
export interface SubmitButtonOptions {
	/**
	 * @deprecated Use `useBuiltInButton` instead
	 */
	visible?: boolean;
	useBuiltInButton?: boolean;
	onVisible?: (isVisible: boolean, context: {
		currentSceneId: string;
		previousSceneId?: string;
	}) => void;
	onContentChange?: (content: string, context: {
		currentSceneId: string;
	}) => void;
	onDisable?: (isDisabled: boolean, context: {
		currentSceneId: string;
	}) => void;
	onLoading?: (isLoading: boolean, context: {
		currentSceneId: string;
	}) => void;
}
export interface ProcessingIndicatorOptions {
	visible?: boolean;
}
export interface FormOptions {
	inputLabelsVisible?: boolean;
}
export declare type CardNetwork = "american-express" | "diners-club" | "discover" | "elo" | "hiper" | "hipercard" | "interac" | "jcb" | "maestro" | "mastercard" | "mir" | "unionpay" | "private-label" | "visa";
export interface ErrorMessageOptions {
	disabled?: boolean;
	onErrorMessageShow?: (message: string) => void;
	onErrorMessageHide?: () => void;
}
export declare enum SuccessScreenType {
	/**
	 * @deprecated Use `PAYMENT_METHOD` instead
	 */
	PaymentMethod = "PaymentMethod",
	PAYMENT_METHOD = "PAYMENT_METHOD",
	CHECK = "CHECK"
}
export declare type CheckSuccessScreenOptions = {
	type: SuccessScreenType.CHECK;
	title: Label;
};
export declare type PaymentMethodSuccessScreenOptions = {
	type: SuccessScreenType.PAYMENT_METHOD;
};
export declare type SuccessScreenOptions = /* No success screen will be displayed */ false | /* Show the default success screen of the payment method*/ undefined | CheckSuccessScreenOptions | PaymentMethodSuccessScreenOptions;
export declare type SuccessCallbackReturnType = /* Show success screen (for backward compatibility) */ undefined | /* Show success screen */ true | /* Refresh client token and perform new step */ {
	clientToken: string;
};
export declare type VaultOptions = {
	visible?: boolean;
	deletionDisabled?: boolean;
};
export declare type TransitionType = "SLIDE_UP" | "SLIDE_DOWN" | "SLIDE_HORIZONTAL";
export declare type SceneTransitionOptions = {
	type: TransitionType;
	duration: number;
	isRtlLocale?: boolean;
};
export declare type SceneOptions = {
	onEntering?: (sceneId: string) => void;
	transition?: SceneTransitionOptions | false;
};
export declare type ClientSessionAction = {
	type: ActionType;
	params?: ActionParameters;
};
export declare type ActionType = "SELECT_PAYMENT_METHOD" | "UNSELECT_PAYMENT_METHOD" | "SET_BILLING_ADDRESS" | "SET_EMAIL_ADDRESS";
export declare type ActionParameters = SelectPaymentMethodParamters | DefaulActionParameters | SetBillingAddressParameters | SetCustomerInformationParameters;
export declare type SelectPaymentMethodParamters = {
	paymentMethodType: string;
	binData?: BinData;
};
export declare type DefaulActionParameters = {
	type: string;
};
export declare type SetBillingAddressParameters = {
	billingAddress: {
		postalCode: string;
	};
};
export declare type SetCustomerInformationParameters = {
	emailAddress?: string;
};
export interface BinData {
	network?: string;
	issuerCountryCode?: string;
	issuerName?: string;
	issuerCurrencyCode?: string;
	regionalRestriction?: string;
	accountNumberType?: string;
	accountFundingType?: string;
	prepaidReloadableIndicator?: string;
	productUsageType?: string;
	productCode?: string;
	productName?: string;
}
export declare type ClientSessionActionData = {
	actions: ClientSessionAction[];
	clientToken?: string;
};
export declare type OnTokenizeShouldStart = () => boolean | Promise<boolean>;
export declare type OnTokenizeDidNotStart = (reason: string) => void;
export declare type RedirectOptions = {
	returnUrl?: string;
	/**
	 * default: false
	 */
	forceRedirect?: boolean;
};
export declare type AdvancedOptions = {
	platform?: "STANDALONE" | "MAGENTO";
};
export interface SinglePaymentMethodCheckoutOptions {
	countryCode?: Alpha2CountryCode;
	/**
	 * @deprecated Use `orderDetails` instead
	 */
	purchaseInfo?: PurchaseInformation;
	uxFlow: CheckoutUXFlow.SINGLE_PAYMENT_METHOD_CHECKOUT;
	scene?: SceneOptions;
	container: string | Element;
	paymentMethod: PaymentMethodType;
	locale?: SupportedLocale;
	allowedCardNetworks?: CardNetwork[];
	onTokenizeShouldStart?: OnTokenizeShouldStart;
	onTokenizeDidNotStart: OnTokenizeDidNotStart;
	onTokenizeStart?: () => void;
	onTokenizeSuccess: (data: PaymentMethodToken) => void | Promise<SuccessCallbackReturnType>;
	onTokenizeError?: (error: PrimerClientError) => void;
	onTokenizeProgress?: (evt: {
		type: string;
	}) => void;
	onResumeSuccess: (data: ResumeToken) => Promise<SuccessCallbackReturnType>;
	onResumeError?: (error: PrimerClientError) => void;
	onAmountChange?: (data: AmountChange) => void;
	onAmountChanging?: (isChanging: boolean) => void;
	onAmountChangeError?: (error: PrimerClientError) => void;
	onClientSessionActions?: (data: ClientSessionActionData) => Promise<{
		clientToken: string;
	} | false>;
	threeDSecure?: ThreeDSVerificationOptions;
	card?: CheckoutCardOptions;
	giftCard?: CustomizablePaymentMethodButton;
	paypal?: Omit<PayPalOptions, "container">;
	googlePay?: Omit<GooglePayOptions, "container">;
	applePay?: Omit<ApplePayOptions, "container">;
	klarna?: KlarnaOptions;
	directDebit?: DirectDebitOptions;
	submitButton?: SubmitButtonOptions;
	processingIndicator?: ProcessingIndicatorOptions;
	style?: CheckoutStyle;
	errorMessage?: ErrorMessageOptions;
	successScreen?: SuccessScreenOptions;
	form?: FormOptions;
	redirect?: RedirectOptions;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	customerDetails?: CustomerDetails;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	businessDetails?: BusinessDetails;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	orderDetails?: OrderDetails;
}
export interface VaultManagerOptions {
	uxFlow: CheckoutUXFlow.MANAGE_PAYMENT_METHODS;
	scene?: SceneOptions;
	container: string | Element;
	locale?: SupportedLocale;
	card?: CheckoutCardOptions;
	giftCard?: CustomizablePaymentMethodButton;
	allowedCardNetworks?: CardNetwork[];
	onTokenizeShouldStart?: OnTokenizeShouldStart;
	onTokenizeDidNotStart?: OnTokenizeDidNotStart;
	onTokenizeStart?: () => void;
	onTokenizeSuccess: (data: PaymentMethodToken) => void;
	onTokenizeError?: (message: PrimerClientError) => void;
	onClientSessionActions?: (data: ClientSessionActionData) => Promise<{
		clientToken: string;
	} | false>;
	style?: CheckoutStyle;
	directDebit?: DirectDebitOptions;
	errorMessage?: ErrorMessageOptions;
	submitButton?: SubmitButtonOptions;
	threeDSecure?: ThreeDSVerificationOptions;
	countryCode?: Alpha2CountryCode;
	processingIndicator?: ProcessingIndicatorOptions;
	vaultOnly?: boolean;
	/**
	 * @deprecated Use `orderDetails` instead
	 */
	purchaseInfo?: VaultInformation;
	/**
	 * @deprecated Provide details in call to /client-session instead
	 */
	orderDetails?: VaultDetails;
	paypal?: Omit<PayPalOptions, "container">;
	deletionDisabled?: boolean;
	form?: FormOptions;
}
export interface CheckoutOptions {
	countryCode?: Alpha2CountryCode;
	/**
	 * @deprecated Use `orderDetails` instead
	 */
	purchaseInfo?: PurchaseInformation;
	uxFlow?: CheckoutUXFlow.CHECKOUT;
	scene?: SceneOptions;
	container: string | Element;
	locale?: SupportedLocale;
	/**
	 * @deprecated Pass `customerId` in the creation of the Client Session
	 */
	customerId?: string;
	allowedCardNetworks?: CardNetwork[];
	allowedPaymentMethods?: PaymentMethodType[];
	vault?: VaultOptions;
	onTokenizeShouldStart?: OnTokenizeShouldStart;
	onTokenizeDidNotStart?: OnTokenizeDidNotStart;
	onTokenizeStart?: () => void;
	onTokenizeSuccess: (data: PaymentMethodToken) => Promise<SuccessCallbackReturnType>;
	onTokenizeError?: (error: PrimerClientError) => void;
	onTokenizeProgress?: (evt: {
		type: string;
	}) => void;
	onResumeSuccess: (data: ResumeToken) => Promise<SuccessCallbackReturnType>;
	onResumeError?: (error: PrimerClientError) => void;
	onAmountChange?: (data: AmountChange) => void;
	onAmountChanging?: (isChanging: boolean) => void;
	onAmountChangeError?: (error: PrimerClientError) => void;
	onClientSessionActions?: (data: ClientSessionActionData) => Promise<{
		clientToken: string;
	} | false>;
	threeDSecure?: ThreeDSVerificationOptions;
	card?: CheckoutCardOptions;
	giftCard?: CustomizablePaymentMethodButton;
	paypal?: Omit<PayPalOptions, "container">;
	googlePay?: Omit<GooglePayOptions, "container">;
	applePay?: Omit<ApplePayOptions, "container">;
	klarna?: KlarnaOptions;
	directDebit?: DirectDebitOptions;
	submitButton?: SubmitButtonOptions;
	processingIndicator?: ProcessingIndicatorOptions;
	style?: CheckoutStyle;
	errorMessage?: ErrorMessageOptions;
	successScreen?: SuccessScreenOptions;
	form?: FormOptions;
	redirect?: RedirectOptions;
	advanced?: AdvancedOptions;
	/**
	 * @deprecated Provide details in call to /client-session instead
	 */
	customerDetails?: CustomerDetails;
	/**
	 * @deprecated Provide details in call to /client-session instead
	 */
	businessDetails?: BusinessDetails;
	/**
	 * @deprecated Provide details in call to /client-session instead
	 */
	orderDetails?: OrderDetails;
}
export declare type FieldMetadata = {
	error?: string;
	valid: boolean;
	active: boolean;
	dirty: boolean;
	touched: boolean;
	submitted: boolean;
};
export declare type CreditCardFieldConfig = {
	container: string;
	placement?: "append" | "prepend";
	placeholder?: string;
	onChange: (data: {
		meta: FieldMetadata;
	}) => void;
};
export interface RenderOptions {
	uxFlow: null;
	locale?: string;
	countryCode?: Alpha2CountryCode;
	/**
	 * @deprecated Use `orderDetails` instead
	 */
	purchaseInfo?: PurchaseInformation;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	customerDetails?: CustomerDetails;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	businessDetails?: BusinessDetails;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	orderDetails?: OrderDetails;
	onTokenizeStart?: () => void;
	onTokenizeSuccess: (data: PaymentMethodToken) => void;
	onTokenizeError?: (error: PrimerClientError) => void;
	onTokenizeProgress?: (evt: {
		type: string;
	}) => void;
	onClientSessionActions?: (data: ClientSessionActionData) => Promise<{
		clientToken: string;
	} | false>;
	card?: {
		cardholderName?: MaybeThunk<string>;
		onChange?: (state: FormState) => void;
		onCardMetadata?: (meta: CardMetadata) => void;
		disabled?: () => boolean;
		css?: string;
		submitButton: string;
		fields: {
			cardNumber: CreditCardFieldConfig;
			expiryDate: CreditCardFieldConfig;
			cvv: CreditCardFieldConfig;
		};
	};
	applePay?: {
		container: string;
	};
	googlePay?: {
		container: string;
	};
	paypal?: {
		container: string;
	};
}
export interface PrimerCheckout {
	teardown(): void;
	/**
	 * @deprecated Use `submit` instead
	 */
	validate(): Promise<Validation>;
	/**
	 * @deprecated Use `submit` instead
	 */
	tokenize(): void;
	submit(): void;
	setTokenizationEnabled(isEnabled: boolean): void;
	/**
	 * @deprecated Use `setOrderDetails` instead
	 */
	setPurchaseInfo(purchaseInfo: PurchaseInformation): Promise<void>;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	setCustomerDetails(customerDetails: CustomerDetails | null): Promise<void>;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	setBusinessDetails(businessDetails: BusinessDetails | null): Promise<void>;
	/**
	 * @deprecated Use setClientToken with new client token instead
	 */
	setOrderDetails(orderDetails: OrderDetails | null, orderDetailsInitiator: string | null): Promise<void>;
	setClientToken(clientToken: string): Promise<boolean>;
}
export interface PrimerSinglePaymentMethodCheckout {
	/**
	 * @deprecated Use `submit` instead
	 */
	validate(): Promise<Validation>;
	/**
	 * @deprecated Use `submit` instead
	 */
	tokenize(): void;
	submit(): void;
	setClientToken(clientToken: string): Promise<boolean>;
}
export interface PrimerVaultManager {
	teardown(): void;
	/**
	 * @deprecated Use `submit` instead
	 */
	validate(): Promise<Validation>;
	/**
	 * @deprecated Use `submit` instead
	 */
	tokenize(): void;
	submit(): void;
}
export interface CardDetails {
	last4Digits: string;
	cardNumber: string;
	name: string;
	icon: string;
	network: string;
	userDescription?: string;
}
export interface PayPalDetails {
	icon: string;
	email?: string;
}
export interface CustomizablePaymentMethodButton {
	logoSrc: string;
	background: string;
	logoAlt?: string;
	text?: string;
}
export interface VaultListItem {
	id: string;
	type: PaymentInstrumentType;
	details: CardDetails | PayPalDetails;
}
export interface RemotePaymentMethodConfiguration<T> {
	id: string;
	options: T;
}
export interface ErrorMonitoring {
	captureException(error: Error): any;
}
declare enum ApiEvent {
	startedCheckout = "STARTED_CHECKOUT",
	loadedCheckoutUi = "LOADED_CHECKOUT_UI",
	loadedVaultManagerUi = "LOADED_VAULT_MANAGER_UI",
	completedCheckout = "COMPLETED_CHECKOUT",
	triggered3ds = "TRIGGERED_3DS",
	validationError = "VALIDATION_ERROR",
	tokenizationError = "TOKENIZATION_ERROR",
	threeDSecureError = "3DS_ERROR",
	threeDSecureFailed = "3DS_FAIL",
	threeDSecureSuccess = "3DS_SUCCESS",
	threeDSecureSkipped = "3DS_SKIPPED",
	tokenizeCalled = "TOKENIZE_CALLED",
	creditCardValidationSuccess = "CREDIT_CARD_VALIDATION_SUCCESS",
	creditCardValidationError = "CREDIT_CARD_VALIDATION_ERROR"
}
declare enum ClickEvent {
	clickedSubmitButton = "CLICKED_SUBMIT_BUTTON",
	clickedAPMButton = "CLICKED_APM_BUTTON",
	clickedPayPalButton = "CLICKED_PAYPAL_BUTTON",
	clickedDirectDebitButton = "CLICKED_DIRECT_DEBIT_BUTTON",
	clickedApplePayButton = "CLICKED_APPLE_PAY_BUTTON",
	clickedGooglePayButton = "CLICKED_GOOGLE_PAY_BUTTON",
	clickedKlarnaButton = "CLICKED_KLARNA_BUTTON"
}
declare enum MockEvent {
	mock = "MOCK"
}
export interface AnalyticsData extends Record<string, any> {
	sdkEnvironment?: string;
	paymentIntent?: string;
	paymentMethod?: PaymentInstrumentType;
	amount?: number;
	currency?: string;
	sdkVersion?: string;
	isVault?: boolean;
	uxFlow?: string;
	sessionId?: string;
}
export interface AnalyticsAction {
	event: ApiEvent | ClickEvent | MockEvent | string;
	data?: AnalyticsData;
}
export interface IAnalyticsProvider {
	call(action: AnalyticsAction): void | boolean;
	time(action: AnalyticsAction): void | boolean;
}
export interface IAnalyticsContext {
	amount?: number | undefined;
	currency?: string | undefined;
	isVault?: boolean | undefined;
	paymentIntent?: string | undefined;
	sdkEnvironment?: string | undefined;
	sessionId?: string | undefined;
}
declare class Analytics {
	provider: IAnalyticsProvider;
	private sessionId;
	private context;
	private sdkEnvironment;
	private paymentIntent;
	constructor(provider: IAnalyticsProvider);
	/** track event and send to Primer. */
	call(action: AnalyticsAction): boolean | void;
	/** start timing event that might happen in the future. */
	time(action: AnalyticsAction): boolean | void;
	/** updates analytics about the context the checkout is in. */
	setContext(context: IAnalyticsContext): void;
	setSdkEnvironment(env: string): void;
	setPaymentIntent(intent: string): void;
	setSessionId(id: string): void;
	getAnalyticsAction(action: AnalyticsAction): AnalyticsAction;
}
export interface PackageDeclaration {
	type: string;
	version: string;
	name: string;
	entryPoints: Record<string, string>;
	getScenePath?: (sceneId: string) => string | null;
}
export interface BaseModule {
	default: unknown;
}
declare enum ModuleStatus {
	UNINITIALIZED = 0,
	LOADING = 1,
	READY = 2,
	ERROR = 3
}
export interface ModuleKey {
	entryPoint: string;
	scope: string;
	path: string;
}
export interface ModuleKeyDescriptor {
	remotePath: string;
	entryFile?: string;
	scope: string;
	path: string;
}
export interface PackageKey {
	remotePath: string;
	entryFile?: string;
	scope: string;
}
export interface ModuleLoadCallback {
	(moduleDescriptor: ModuleDescriptor): void;
}
export interface ModuleDescriptor {
	key: ModuleKey;
	status: ModuleStatus;
	callbacks: Array<ModuleLoadCallback>;
	module: BaseModule | null;
}
export interface IModuleLoader {
	loadModule(key: ModuleKey): Promise<ModuleDescriptor>;
}
export interface IModule {
	import(exportName?: string): Promise<unknown>;
}
export interface IPackage {
	key: PackageKey;
	getDeclaration(): Promise<PackageDeclaration>;
	getModule(string: any): IModule;
}
export interface IModuleFactory {
	getPackage(packageKey: PackageKey): IPackage;
	getModule(keyDescriptor: ModuleKeyDescriptor): IModule;
}
export interface ModuleOptions {
	key: ModuleKey;
	moduleLoader: IModuleLoader;
}
declare class Module implements IModule {
	readonly key: ModuleKey;
	readonly status: ModuleStatus;
	private moduleLoader;
	constructor({ key, moduleLoader }: ModuleOptions);
	import(exportName?: string): Promise<unknown>;
}
export interface ScriptLoaderOptions {
	thirdPartyScriptTimeout?: number;
}
declare class ScriptLoader {
	private scripts;
	private timeoutMilliseconds;
	constructor(options?: ScriptLoaderOptions);
	load(src: string, options?: {
		crossorigin?: "anonymous" | "use-credentials";
	}): Promise<boolean>;
}
declare class ModuleFactory implements IModuleFactory {
	private moduleLoader;
	private modules;
	private packages;
	constructor(scriptLoader: ScriptLoader);
	getModule(keyDescriptor: ModuleKeyDescriptor): Module;
	getPackage(key: PackageKey): any;
	private findModule;
	private findPackage;
}
export declare type Props = {
	moduleFactory: IModuleFactory;
	key: PackageKey;
};
declare class Package implements IPackage {
	readonly key: PackageKey;
	private moduleFactory;
	private declarationModule;
	constructor({ moduleFactory, key }: Props);
	getDeclaration(): Promise<PackageDeclaration>;
	getModule(path: string): IModule;
}
export interface IFrameMessagePayloadMeta {
	source: string;
	destination: string | null;
	name?: string;
	id?: string;
	replyTo?: string;
	[x: string]: unknown;
}
export interface IFrameInputMessagePayload<T = unknown> {
	type: string;
	meta?: Partial<IFrameMessagePayloadMeta>;
	payload?: T;
}
export interface IFrameMessagePayload<T = unknown> {
	type: string;
	meta: IFrameMessagePayloadMeta;
	payload: T;
}
export interface Observer {
	(event: IFrameMessagePayload): void;
}
declare class Observable {
	private observers;
	constructor();
	onEvent(event: IFrameMessagePayload): void;
	on(type: string, observer: Observer): void;
	once(type: string, observer: Observer): void;
	notify(event: IFrameMessagePayload): void;
}
declare class IFrameMessageBus extends Observable {
	private frames;
	constructor();
	onEvent(event: IFrameMessagePayload): void;
	add(iframe: HTMLIFrameElement): void;
	publish(name: string, event: IFrameInputMessagePayload): void;
	rpc(name: string, evt: IFrameInputMessagePayload): Promise<IFrameMessagePayload>;
}
export declare type IFramePlacement = "append" | "prepend";
export interface IFrameFactoryOptions {
	messageBus: IFrameMessageBus;
	assetsUrl: string;
}
export interface CreateIFrameOptions {
	filename: string;
	container: string | Element;
	placement?: IFramePlacement;
	payload?: unknown;
	meta: {
		name: string;
		id?: string;
		ariaLabel?: string;
		placeholder?: string;
		css?: string;
		stylesheets?: string[];
		allowedCardNetworks?: CardNetwork[];
	};
	style?: Record<string, string>;
	onReady?: () => void;
}
declare class IFrameFactory {
	private id;
	private messageBus;
	private assetsUrl;
	constructor({ messageBus, assetsUrl }: IFrameFactoryOptions);
	create({ filename, container, meta, payload, placement, style, onReady, }: CreateIFrameOptions): HTMLIFrameElement | null;
}
declare enum HttpMethod {
	GET = "get",
	POST = "post",
	DELETE = "delete"
}
export interface APIServices {
	messageBus: IFrameMessageBus;
	iframes: IFrameFactory;
	accessToken: string;
}
export interface RequestOptions {
	maxAttempts?: number;
	apiVersion?: string;
}
export interface APIRequestOptions {
	method: HttpMethod;
	url: string;
	body?: unknown;
	options: RequestOptions;
}
export interface ValidationError {
	description: string;
	path: string;
}
export interface ValidationErrorDetail {
	model: string;
	errors: ValidationError[];
}
export interface APIErrorShape {
	message: string;
	validationErrors: ValidationErrorDetail[];
	diagnosticsId?: string;
	errorId?: string;
}
export interface APIResponse<T = unknown> {
	error: Nullable<APIErrorShape>;
	data: Nullable<T>;
}
declare class Api {
	private messageBus;
	private isReady;
	private onReadyCallback;
	constructor(services: APIServices);
	setAccessToken(accessToken: string): void;
	ready(): Promise<void>;
	request<T>(payload: APIRequestOptions): Promise<APIResponse<T>>;
	post<T = unknown, U = unknown>(url: string, body: T, options?: RequestOptions): Promise<APIResponse<U>>;
	get<T>(url: string, options?: RequestOptions): Promise<APIResponse<T>>;
	delete<T>(url: string, options?: RequestOptions): Promise<APIResponse<T>>;
}
declare enum ClientTokenIntent {
	CHECKOUT = "CHECKOUT",
	THREEDS_AUTHENTICATION = "3DS_AUTHENTICATION",
	PROCESSOR_3DS = "PROCESSOR_3DS",
	REDIRECTION_END = "REDIRECTION_END"
}
export declare type CommonClientToken = {
	configurationUrl: string;
	analyticsUrl?: string;
	accessToken: string;
	paymentFlow: PaymentFlow;
};
export declare type IntentClientToken = {
	intent: ClientTokenIntent.CHECKOUT | undefined;
} | {
	intent: ClientTokenIntent.THREEDS_AUTHENTICATION;
	tokenId: string;
	threeDSProvider: string;
	threeDSToken: string;
	threeDSInitUrl: string;
} | {
	intent: ClientTokenIntent.REDIRECTION_END;
	paymentId: string;
	resumeToken: string;
} | ({
	intent: string;
} & Record<string, unknown>);
export declare type DecodedClientToken = CommonClientToken & IntentClientToken;
export declare type NewClientTokenListener = (decodedClientToken: DecodedClientToken) => void;
export interface IClientTokenHandler {
	setClientToken(clientToken: string): any;
	getCurrentClientToken(): string | undefined;
	getCurrentDecodedClientToken(): DecodedClientToken | undefined;
	addNewClientTokenListener(listener: NewClientTokenListener): any;
	removeNewClientTokenListener(listener: NewClientTokenListener): any;
}
declare class ClientTokenHandler implements IClientTokenHandler {
	private newClientTokenListeners;
	private currentClientToken;
	private currentDecodedClientToken;
	constructor();
	getCurrentClientToken(): string | undefined;
	getCurrentDecodedClientToken(): (CommonClientToken & {
		intent: ClientTokenIntent.CHECKOUT | undefined;
	}) | (CommonClientToken & {
		intent: ClientTokenIntent.THREEDS_AUTHENTICATION;
		tokenId: string;
		threeDSProvider: string;
		threeDSToken: string;
		threeDSInitUrl: string;
	}) | (CommonClientToken & {
		intent: ClientTokenIntent.REDIRECTION_END;
		paymentId: string;
		resumeToken: string;
	}) | (CommonClientToken & {
		intent: string;
	} & Record<string, unknown>) | undefined;
	setClientToken(clientToken: string): void;
	addNewClientTokenListener(listener: NewClientTokenListener): void;
	removeNewClientTokenListener(listener: NewClientTokenListener): void;
}
declare class ClientConfigurationHandler {
	private api;
	private clientTokenHandler;
	constructor(api: Api, clientTokenHandler: ClientTokenHandler);
	getClientConfiguration(clientToken: string): Promise<ClientConfiguration>;
}
export interface LongPollServices {
	api: Api;
}
export interface LongPollOptions<T> {
	url: string;
	timeout: number;
	pollInterval: number;
	predicate(response: T): boolean;
}
declare class LongPoll {
	private api;
	private isStarted;
	constructor(services: LongPollServices);
	start<T>(options: LongPollOptions<T>): Promise<T | null>;
	stop(): void;
	private request;
	private tick;
}
export interface PaymentMethodConfig {
	id: string;
	type: PaymentMethodType;
	options: {
		threeDSecureToken?: string;
		threeDSecureInitUrl?: string;
		threeDSecureProvider?: string;
		threeDSecureEnabled?: boolean;
	} | any;
}
export interface CheckoutModuleConfig extends Record<string, any> {
	type: string;
}
export interface ClientSessionInfo {
	assetsUrl: string;
	coreUrl: string;
	pciUrl: string;
	modulesUrl: string;
	env: string;
	production: boolean;
	paymentFlow: PaymentFlow;
	paymentMethods: PaymentMethodConfig[];
	checkoutModules: CheckoutModuleConfig[];
	threeDSecureToken: Nullable<string>;
	threeDSecureInitUrl: Nullable<string>;
	threeDSecureProvider: Nullable<string>;
	threeDSecureEnabled: boolean;
	accessToken: string;
	isTeardown: boolean;
	clientSession: ClientSession;
}
export interface ClientContext {
	clientTokenHandler: IClientTokenHandler;
	clientConfigurationHandler: ClientConfigurationHandler;
	iframes: IFrameFactory;
	messageBus: IFrameMessageBus;
	api: Api;
	longPoll: LongPoll;
	analytics: Analytics;
	errorMonitoring: ErrorMonitoring;
	scriptLoader: ScriptLoader;
	session: ClientSessionInfo;
	moduleFactory: ModuleFactory;
	packages: Package[];
	clientOptions: CheckoutOptions | VaultManagerOptions | SinglePaymentMethodCheckoutOptions | RenderOptions;
}
export interface ClientConfiguration {
	coreUrl: string;
	pciUrl: string;
	env: string;
	paymentMethods: PaymentMethodConfig[];
	checkoutModules: CheckoutModuleConfig[];
	clientSession: ClientSession;
}
declare class ThreeDSecure {
	private context;
	private provider;
	constructor({ context }: {
		context: ClientContext;
	});
	getContext(): Promise<ClientContext>;
	getProvider(): Promise<any>;
	setup(options: Record<string, unknown>): Promise<void>;
	verify(options: Record<string, unknown>): Promise<any>;
}
export interface IBaseState extends Record<string, any> {
}
export interface IBaseStore {
	getState(): IBaseState;
	subscribe(listener: any): any;
}
export interface IStyleManagerOptions {
	isRtlLocale?: boolean;
}
export interface IStyleManager {
	setStyle(style?: CheckoutStyle, internalStyle?: InternalStyle, options?: IStyleManagerOptions): void;
	getStyle(): CheckoutStyle | undefined;
	getHostedFieldStyle(): string | null;
	getApmButtonStyle(): PaymentMethodButtonStyle | null;
}
export declare type PaymentMethodSpecs = {
	key: string;
	buttonManagedByPaymentMethod: boolean;
	canVault: boolean;
	hasExportedButtonOptions: boolean;
	homeScene?: string;
};
declare class BasePaymentMethod {
	static specs: PaymentMethodSpecs;
	readonly type: PaymentMethodType;
	displayName: string;
	container: Element | null;
	remoteConfig: any;
	protected constructor(type: PaymentMethodType, name: string);
	static create: (_context: any, _options: Record<string, any>, _remoteConfig: any, _styleManager?: IStyleManager | undefined) => BasePaymentMethod;
	get specs(): PaymentMethodSpecs;
	setupAndValidate(): Promise<boolean>;
	mount(): Promise<boolean>;
	tokenize(options?: any): Promise<void>;
	validate(): Promise<Validation>;
	setDisabled(disabled: boolean): Promise<void>;
	getStore(): IBaseStore | undefined;
}
declare class Client {
	static CheckoutUXFlow: typeof CheckoutUXFlow;
	static ThreeDSecureStatus: typeof ThreeDSecureStatus;
	static PaymentFlow: typeof PaymentFlow;
	static PaymentMethodType: typeof PaymentMethodType;
	static SDK_VERSION: unknown;
	private options;
	private currentContextPromise;
	private currentContext;
	constructor(options: ClientContextOptions);
	private getContext;
	render(options: RenderOptions): Promise<Record<string, BasePaymentMethod>>;
	checkout(options: CheckoutOptions | VaultManagerOptions | SinglePaymentMethodCheckoutOptions): Promise<PrimerVaultManager | PrimerCheckout | PrimerSinglePaymentMethodCheckout>;
	get threeDSecure(): ThreeDSecure | null;
}
export declare type PrimerClient = Client;
export declare type PrimerClientConstructor = typeof Client;
export declare const loadPrimer: () => Promise<PrimerClientConstructor>;

export {};
